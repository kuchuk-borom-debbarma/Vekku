
# ðŸ““ Vekku Project Journal
**Entry:** 002
**Date:** 2025-12-15
**Phase:** Implementation / Foundation

## 1. Concrete Implementation: The Tag Service
Following the architectural definition in Entry 001, I have successfully implemented the first pillar of the triad: **`TagService` ("The Librarian")**.

We have moved from abstract concepts to concrete code, utilizing **Neo4j** as the backing store to handle complex hierarchical relationships.

## 2. Modeling the Graph
The core of this implementation is the `Tag` entity. Instead of a traditional SQL table where hierarchy is clumsy (often requiring recursive joins), we modeled the Tag as a First-Class Citizen of the Graph.

### Key Decisions:
1.  **Nodes & Edges**: We defined `Tag` as a `@Node`. The relationship between tags is defined as `CHILD_OF`.
2.  **Polyhierarchy**: By using a `Set<Tag> parents`, we explicitly support tags having multiple parents.
    *   *Example*: "Spring Boot" can be a child of both "Java" AND "Framework").
    *   This prevents the "folder trap" where an item can only live in one place.

## 3. The Power of Recursion
One of the biggest wins of using Neo4j here became apparent in the "Ancestors" feature. To find where a tag sits in the grand scheme of things, we used Cypher's variable length path matching:

```cypher
MATCH (t:Tag {name: $name})-[:CHILD_OF*]->(parent:Tag) RETURN parent
```

The `*` operator effectively says "Keep walking up the tree until you hit the root." This allows us to retrieve the entire lineage of a tag in a single, efficient database query, rather than looping in Java code.

## 4. Verification: The CLI
To avoid getting bogged down in UI development too early, I implemented a **Spring Shell** CLI (`VekkuCommands.java`). This allows us to interact with "The Librarian" directly from the terminal:
*   `tag create <name>`
*   `tag create <name> --parent <parent>`
*   `tag ancestors <name>`

This approach verified that our graph logic is solid before we even touch a frontend line of code.

---
