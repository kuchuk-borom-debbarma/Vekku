# 1. Context-Aware Tag Resolution ("Smart Refinement")

**Date:** 2025-12-16
**Status:** Proposal / Design Phase

## 1. Overview
We are enhancing the Vekku tagging system by moving from a purely **Semantic** approach (vectors) to a **Hybrid** approach (Semantic + Structural).

### The Problem
- **Vector Search (Qdrant)** is excellent at "fuzzy matching" (finding "Canine" when you search "Dog"). However, it lacks precision and awareness of the specific taxonomy maintained in our system. It often suggests generic terms ("Programming") instead of specific ones ("TypeScript") or gets confused by polysemy ("Apple" fruit vs brand).
- **Knowledge Graph (Neo4j)** represents the "Truth" of our taxonomy but cannot inherently understand unstructured text.

### The Solution: "Smart Refinement"
We propose a pipeline that uses the Vector store as a "Broad Net" and the Graph as a "context-aware filter" to refine suggestions.

---

## 2. The "Sieve" Architecture

The process follows a **Scout -> Inspect -> Anchor** workflow.

### Phase 1: The Scout (Broad Search)
*   **Role:** Qdrant (Brain Service)
*   **Action:** Query the vector database with the content chunk.
*   **Goal:** Retrieve a wide set of potentially relevant candidates (e.g., Top 20), prioritizing recall over precision.
*   **Output:** A list of "Loose Tags" (e.g., `[Apple, Stock, Market, Banana]`).

### Phase 2: The Inspector (Structure Check)
*   **Role:** Neo4j (Graph Service)
*   **Action:** For every "Loose Tag", traverse its immediate neighborhood (Parents and Children).
*   **Goal:** Identify **Clusters of Validity**.
    *   If `Apple` and `Banana` both appear, their common parent `Fruit` creates a "Fruit Cluster".
    *   If `Apple` and `Stock` both appear, their connectivity via `Brand` -> `Finance` creates a "Finance Cluster".

### Phase 3: The Refiner (Drill Down & Anchor)
*   **Role:** Refinement Logic
*   **Action:** Adjust the final list based on two rules:

#### Rule A: "Drill Down" (Specificity)
*   **Principle:** Always prefer the most specific valid node.
*   **Logic:** If the generic tag `Programming` is found, check its children (`Python`, `JS`, etc.). If a child's vector score is high enough (threshold check), **replace** the parent with the child.
    *   *Result:* User gets `TypeScript` instead of `Programming`.

#### Rule B: "Anchor" (Context Disambiguation)
*   **Principle:** Use the dominant cluster to resolve ambiguity.
*   **Logic:**
    *   `Apple` has two parents: `Fruit` and `Brand`.
    *   The context contains `Stock` (Finance).
    *   The "Finance Cluster" is denser than the "Fruit Cluster" (which only has `Apple`).
    *   *Result:* Anchor `Apple` to the `Brand` context. Discard `Fruit` context.

---

## 3. Handling Poly-Hierarchy
Vekku's graph allows tags to have multiple parents (e.g., `React` is child of `Library` AND `Meta`).
*   **Benefit:** multiple parents provide **more signal paths**.
*   In the anchoring phase, if *any* parent path connects well with the other tags in the text, that tag is validated.
*   This makes the system highly robust against "isolated" false positives (random vector matches that have no structural relation to the rest of the content).

## 4. Proposed Data Flow

1.  **Input:** Unstructured Text Chunk.
2.  **Step 1 (Vectors):** `BrainService` -> `Qdrant` -> Returns `List<CandidateTag>`.
3.  **Step 2 (Enrichment):** `TagService` -> `Neo4j` -> Fetches `Parents` and `Children` for all candidates.
4.  **Step 3 (Refinement):** Run `CoherenceAlgorithm(candidates, neighborhoods)`.
5.  **Output:** `List<RefinedTag>` (Specific, Context-Validated).
