# 3. Poly-Hierarchy Implementation & Serialization Fix

**Date:** 2025-12-16
**Commit:** 4c941df

## 1. Overview
Following the architectural shift to Poly-Hierarchy, we have completed the implementation of the path retrieval and disambiguation logic. This phase primarily focused on solving a critical data mapping issue with Spring Data Neo4j (SDN) and implementing the "Root Score Wins" strategy for tag selection.

## 2. Feature: Path Disambiguation ("Root Score Wins")
In a DAG (Directed Acyclic Graph), a tag like `React` can have multiple lineages:
1.  `Library -> React`
2.  `Meta -> React`

To present the single most relevant path to the user, we implemented the **"Root Score Wins"** strategy:
*   We identify the root node of every potential path (`Library`, `Meta`).
*   We check the relevance score of these roots against the content.
*   The path whose root has the highest score is selected.
*   **Why?** This ensures the *context* matches. If the text is about "Open Source Corporate Projects", `Meta` might score higher. If it's about "Frontend Dependencies", `Library` wins.

## 3. The "Missing Path" Bug
During implementation, we encountered a severe issue where paths were returning as fragmented, single-node lists (e.g., `[Java]`, `[Languages]`) instead of a connected chain `[Java, Languages, Programming]`.

### The Cause
Spring Data Neo4j's Object-Graph Mapper (OGM) struggled to correctly map the `nodes(p)` result from a variable-length path query into a `List<Tag>` when those tags were complex entities. It likely treated each node in the path as a disjoint result row.

### The Fix: Cypher String Serialization
Instead of relying on SDN to map the path objects, we essentially "serialized" the path structure directly in the database using Cypher.

 **Old Query (Broken Mapping):**
```cypher
MATCH p=(leaf:Tag)-[:CHILD_OF*]->(root) RETURN nodes(p)
```

**New Query (Serialized):**
```cypher
MATCH p=(leaf:Tag)-[:CHILD_OF*]->(root)
RETURN reduce(s = head(nodes(p)).name, n IN tail(nodes(p)) | s + '$$$' + n.name)
```

This returns a single string: `"Java$$$Languages$$$Programming"`.
We then parse this string in the Java service. This guarantee structural integrity by bypassing the complex object mapping layer for this specific operation.

## 4. Final Output Verification
The system now correctly outputs:
```text
REGION: "fixing a NullPointerException..."
-> Java (0.95)
   Path: Education -> Software Engineering -> Programming -> Languages -> Java
```
Full lineage is preserved, context is disambiguated, and performance remains high.
